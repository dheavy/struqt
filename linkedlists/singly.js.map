{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///singly.js","webpack:///webpack/bootstrap f65f92e0f458f99e196d","webpack:///./src/linkedlists/singly.js","webpack:///external \"deep-equal\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","List","clear","areEquals","prototype","add","data","node","next","size","tail","head","oldTail","addAll","_this","_len","arguments","length","Array","_key","forEach","addAtIndex","index","RangeError","cursor","prev","current","addAllAtIndex","_len2","_key2","endNode","weave","nodes","push","get","remove","deleted","contains","shift","pop","set","clone","Object","assign","create","toArray"],"mappings":"CAAA,SAAAA,EAAAC,GACA,mBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,mBACA,sBAAAC,gBAAAC,IACAD,QAAA,cAAAJ,OACA,CACA,GAAAM,GAAAN,EAAA,gBAAAC,SAAAE,QAAA,cAAAJ,EAAA,cACA,QAAAQ,KAAAD,IAAA,gBAAAL,iBAAAF,GAAAQ,GAAAD,EAAAC,KAECC,KAAA,SAAAC,GACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAX,OAGA,IAAAC,GAAAW,EAAAD,IACAX,WACAa,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAd,EAAAD,QAAAC,IAAAD,QAAAU,GAGAT,EAAAa,QAAA,EAGAb,EAAAD,QAvBA,GAAAY,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAAST,EAAQD,EAASU,GAE/B,YE9CD,SAASS,KACPZ,KAAKa,QAXP,GAAMC,GAAYX,EAAQ,EAoB1BS,GAAKG,UAAUC,IAAM,SAAUC,GAC7B,GAAMC,IAAQD,OAAME,KAAM,KAE1B,IAAkB,IAAdnB,KAAKoB,KAIP,MAHApB,MAAKqB,KAAOH,EACZlB,KAAKsB,KAAKH,KAAOD,EACjBlB,KAAKoB,OACEF,CAGT,IAAMK,GAAUvB,KAAKqB,IAKrB,OAJAE,GAAQJ,KAAOD,EACflB,KAAKqB,KAAOH,EACZlB,KAAKoB,OAEEF,GASTN,EAAKG,UAAUS,OAAS,WAAmB,OAAAC,GAAAzB,KAAA0B,EAAAC,UAAAC,OAANX,EAAMY,MAAAH,GAAAI,EAAA,EAAAA,EAAAJ,EAAAI,IAANb,EAAMa,GAAAH,UAAAG,EAEzC,OADAb,GAAKc,QAAQ,SAAAd,GAAA,MAAQQ,GAAKT,IAAIC,KACvBjB,KAAKqB,MAYdT,EAAKG,UAAUiB,WAAa,SAAUC,EAAOhB,GAC3C,GAAkB,IAAdjB,KAAKoB,MAAca,EAAQ,GAAKA,EAAQjC,KAAKoB,KAC/C,KAAM,IAAIc,YAAW,wBAOvB,KAJA,GAAIC,GAAS,EACTC,EAAOpC,KAAKsB,KACZe,EAAUrC,KAAKsB,KAAKH,KAEjBgB,EAASF,GACdG,EAAOC,EACPA,EAAUA,EAAQlB,KAClBgB,GAGF,IAAMjB,IAAQD,OAAME,KAAMkB,EAK1B,OAJAD,GAAKjB,KAAOD,EAEZlB,KAAKoB,OAEEF,GAaTN,EAAKG,UAAUuB,cAAgB,SAAUL,GAAgB,OAAAM,GAAAZ,UAAAC,OAANX,EAAMY,MAAAU,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANvB,EAAMuB,EAAA,GAAAb,UAAAa,EACvD,IAAkB,IAAdxC,KAAKoB,MAAca,EAAQ,GAAKA,EAAQjC,KAAKoB,KAC/C,KAAM,IAAIc,YAAW,wBAOvB,KAJA,GAAIE,GAAOpC,KAAKsB,KACZe,EAAUrC,KAAKsB,KAAKH,KACpBgB,EAAS,EAENA,EAASF,GACdG,EAAOC,EACPA,EAAUA,EAAQlB,KACbkB,IACHrC,KAAKqB,KAAOe,GAEdD,GAMF,IAAMM,GAAW,QAASC,GAAM3C,EAAG4C,EAAO1B,EAAMmB,EAAMC,GACpD,GAAItC,IAAMkB,EAAKW,OAAQ,CAErBQ,EAAKjB,KAAOwB,EAAM,EAClB,IAAMF,GAAUE,EAAMA,EAAMf,OAAS,EAKrC,OAJAa,GAAQtB,KAAOkB,EAGfM,EAAQ,KACDF,EAIT,GAAMvB,IAAQD,KAAMA,EAAKlB,GAAIoB,KAAM,KAOnC,OANIpB,GAAI,IACN4C,EAAM5C,EAAI,GAAGoB,KAAOD,GAItByB,EAAMC,KAAK1B,GACJwB,IAAQ3C,EAAG4C,EAAO1B,EAAMmB,EAAMC,IACpC,KAAOpB,EAAMmB,EAAMC,EAItB,OAFArC,MAAKoB,MAAQH,EAAKW,OAEXa,GAUT7B,EAAKG,UAAU8B,IAAM,SAAUZ,GAC7B,GAAkB,IAAdjC,KAAKoB,MAAca,EAAQ,GAAKA,EAAQjC,KAAKoB,KAC/C,KAAM,IAAIc,YAAW,wBAMvB,KAHA,GAAIC,GAAS,EACTE,EAAUrC,KAAKsB,KAAKH,KAEjBgB,EAASF,GACdI,EAAUA,EAAQlB,KAClBgB,GAGF,OAAOE,IAUTzB,EAAKG,UAAU+B,OAAS,SAAUb,GAChC,GAAkB,IAAdjC,KAAKoB,MAAca,EAAQ,GAAKA,EAAQjC,KAAKoB,KAC/C,KAAM,IAAIc,YAAW,wBAQvB,KALA,GAAIC,GAAS,EACTC,EAAOpC,KAAKsB,KACZe,EAAUrC,KAAKsB,KAAKH,KACpBA,EAAOkB,EAAQlB,KAEZgB,EAASF,GACdG,EAAOC,EACPA,EAAUA,EAAQlB,KAClBA,EAAOkB,EAAQlB,KACfgB,GAGF,IAAMY,GAAUV,CAQhB,OAPAD,GAAKjB,KAAOA,EACPA,IACHnB,KAAKqB,KAAOe,GAEdC,EAAU,KACVrC,KAAKoB,OAEE2B,GASTnC,EAAKG,UAAUiC,SAAW,SAAU/B,GAClC,GAAIoB,GAAUrC,KAAKsB,KAAKH,IAExB,IAAIL,EAAUuB,EAAQpB,KAAMA,GAC1B,OAAO,CAIT,KADA,GAAIkB,GAAS,EACNA,EAASnC,KAAKoB,MAAM,CAEzB,GADAiB,EAAUA,EAAQlB,KACdL,EAAUuB,EAAQpB,KAAMA,GAC1B,OAAO,CAETkB,KAGF,OAAO,GAQTvB,EAAKG,UAAUkC,MAAQ,WACrB,MAAOjD,MAAK8C,OAAO,IASrBlC,EAAKG,UAAUmC,IAAM,WACnB,MAAOlD,MAAK8C,OAAO9C,KAAKoB,OAU1BR,EAAKG,UAAUoC,IAAM,SAAUlB,EAAOhB,GACpCjB,KAAK6C,IAAIZ,GAAOhB,KAAOA,GAQzBL,EAAKG,UAAUqC,MAAQ,WACrB,MAAOC,QAAOC,OAAOD,OAAOE,OAAOvD,MAAOA,OAQ5CY,EAAKG,UAAUyC,QAAU,WAKvB,IAJA,GAAInB,GAAUrC,KAAKsB,KAAKH,KACpBgB,EAAS,EACTrC,KAEGqC,GAAUnC,KAAKoB,MACpBtB,EAAE8C,KAAKP,EAAQpB,MACfoB,EAAUA,EAAQlB,KAClBgB,GAGF,OAAOrC,IAQTc,EAAKG,UAAUF,MAAQ,WACrBb,KAAKsB,MAAQH,KAAM,MACnBnB,KAAKqB,KAAO,KACZrB,KAAKoB,KAAO,GAGd1B,EAAOD,QAAUmB,GFyEX,SAASlB,EAAQD,GG7WvBC,EAAAD,QAAAE,QAAA","file":"singly.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"deep-equal\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"deep-equal\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"deep-equal\")) : factory(root[\"deep-equal\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"deep-equal\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"deep-equal\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"deep-equal\")) : factory(root[\"deep-equal\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar areEquals = __webpack_require__(1);\n\t\n\t/**\n\t * Singly linked list.\n\t * Its instances contain nodes that are plain old JavaScript objects.\n\t * These nodes have a `data` field containing any value, and a `next` field,\n\t * which points to the next node in line of nodes.\n\t *\n\t * @constructor\n\t */\n\tfunction List() {\n\t  this.clear();\n\t};\n\t\n\t/**\n\t * Append data to a new node at the end of the list.\n\t *\n\t * @param  {*}      data  Any type of data.\n\t * @return {Object} The new node.\n\t */\n\tList.prototype.add = function (data) {\n\t  var node = { data: data, next: null };\n\t\n\t  if (this.size === 0) {\n\t    this.tail = node;\n\t    this.head.next = node;\n\t    this.size++;\n\t    return node;\n\t  }\n\t\n\t  var oldTail = this.tail;\n\t  oldTail.next = node;\n\t  this.tail = node;\n\t  this.size++;\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Append any numbers of elements as new nodes at the end of the list.\n\t *\n\t * @param  {*} ...data  Any numbers of any type of data.\n\t * @return {Object} The last inserted node (tail).\n\t */\n\tList.prototype.addAll = function () {\n\t  var _this = this;\n\t\n\t  for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n\t    data[_key] = arguments[_key];\n\t  }\n\t\n\t  data.forEach(function (data) {\n\t    return _this.add(data);\n\t  });\n\t  return this.tail;\n\t};\n\t\n\t/**\n\t * Append data to a new node placed at the given index of the list.\n\t * Previous owner of this index becomes next in line after the new node.\n\t *\n\t * @param  {integer} index    The index at which the new node should be inserted.\n\t * @param  {*}       element  Any object to be used as data for the node.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object} The newly created node.\n\t */\n\tList.prototype.addAtIndex = function (index, data) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  var node = { data: data, next: current };\n\t  prev.next = node;\n\t\n\t  this.size++;\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Append any number of data to new nodes placed at the given index.\n\t * Previous owner of the index becomes next in line after the latest\n\t * new node.\n\t *\n\t * @param  {integer} index    The index at which the new node should be inserted.\n\t * @param  {*}       ...data  Any number of any type of data.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object} The last of the newly created node.\n\t */\n\tList.prototype.addAllAtIndex = function (index) {\n\t  for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t    data[_key2 - 1] = arguments[_key2];\n\t  }\n\t\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t  var cursor = 1;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    if (!current) {\n\t      this.tail = prev;\n\t    }\n\t    cursor++;\n\t  }\n\t\n\t  // Create array of newly created nodes from data.\n\t  // Process recursively and return reference to the latest\n\t  // node created when done.\n\t  var endNode = function weave(i, nodes, data, prev, current) {\n\t    if (i === data.length) {\n\t      // Transplant both ends of array of new nodes to existing linked list.\n\t      prev.next = nodes[0];\n\t      var _endNode = nodes[nodes.length - 1];\n\t      _endNode.next = current;\n\t\n\t      // Kill references of nodes and return latest one.\n\t      nodes = null;\n\t      return _endNode;\n\t    }\n\t\n\t    // Build node and link reference with previous one.\n\t    var node = { data: data[i], next: null };\n\t    if (i > 0) {\n\t      nodes[i - 1].next = node;\n\t    }\n\t\n\t    // Store node and repeat.\n\t    nodes.push(node);\n\t    return weave(++i, nodes, data, prev, current);\n\t  }(0, [], data, prev, current);\n\t\n\t  this.size += data.length;\n\t\n\t  return endNode;\n\t};\n\t\n\t/**\n\t * Return the node at the specified position.\n\t *\n\t * @param  {integer}    index   The index to look for.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object}  The node at the requested index.\n\t */\n\tList.prototype.get = function (index) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var current = this.head.next;\n\t\n\t  while (cursor < index) {\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  return current;\n\t};\n\t\n\t/**\n\t * Remove the element at a given index.\n\t *\n\t * @param  {integer} index  The index of the node to remove.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object}  The deleted node.\n\t */\n\tList.prototype.remove = function (index) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t  var next = current.next;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    next = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  var deleted = current;\n\t  prev.next = next;\n\t  if (!next) {\n\t    this.tail = prev;\n\t  }\n\t  current = null;\n\t  this.size--;\n\t\n\t  return deleted;\n\t};\n\t\n\t/**\n\t * Return true if this list contains a node holding the specified data.\n\t *\n\t * @param  {*} data   The data to look for within nodes.\n\t * @return {boolean}  True if the data was found in a node.\n\t */\n\tList.prototype.contains = function (data) {\n\t  var current = this.head.next;\n\t\n\t  if (areEquals(current.data, data)) {\n\t    return true;\n\t  }\n\t\n\t  var cursor = 1;\n\t  while (cursor < this.size) {\n\t    current = current.next;\n\t    if (areEquals(current.data, data)) {\n\t      return true;\n\t    }\n\t    cursor++;\n\t  }\n\t\n\t  return false;\n\t};\n\t\n\t/**\n\t * Remove and return the first node.\n\t *\n\t * @return {Object} The removed node.\n\t */\n\tList.prototype.shift = function () {\n\t  return this.remove(1);\n\t};\n\t\n\t/**\n\t * Remove and return the last node.\n\t *\n\t * @return {Object} The removed node.\n\t */\n\tList.prototype.pop = function () {\n\t  return this.remove(this.size);\n\t};\n\t\n\t/**\n\t * Replace data in the node at specified position.\n\t *\n\t * @param  {integer} index  The index of the node to edit.\n\t * @param  {*}       data   Any data to update the node's data field.\n\t * @return {void}\n\t */\n\tList.prototype.set = function (index, data) {\n\t  this.get(index).data = data;\n\t};\n\t\n\t/**\n\t * Return a shallow copy of the list.\n\t *\n\t * @return {Object} A singly linked list instance with copied nodes and data.\n\t */\n\tList.prototype.clone = function () {\n\t  return Object.assign(Object.create(this), this);\n\t};\n\t\n\t/**\n\t * Return an array compiling data from all nodes in the list.\n\t *\n\t * @return {Array}  An array of data based on the actual nodes' data.\n\t */\n\tList.prototype.toArray = function () {\n\t  var current = this.head.next;\n\t  var cursor = 1;\n\t  var a = [];\n\t\n\t  while (cursor <= this.size) {\n\t    a.push(current.data);\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\t/**\n\t * Remove all elements from the list and reseat its head.\n\t *\n\t * @return {void}\n\t */\n\tList.prototype.clear = function () {\n\t  this.head = { next: null };\n\t  this.tail = null;\n\t  this.size = 0;\n\t};\n\t\n\tmodule.exports = List;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"deep-equal\");\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// singly.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f65f92e0f458f99e196d","const areEquals = require('deep-equal');\n\n/**\n * Singly linked list.\n * Its instances contain nodes that are plain old JavaScript objects.\n * These nodes have a `data` field containing any value, and a `next` field,\n * which points to the next node in line of nodes.\n *\n * @constructor\n */\nfunction List() {\n  this.clear();\n};\n\n/**\n * Append data to a new node at the end of the list.\n *\n * @param  {*}      data  Any type of data.\n * @return {Object} The new node.\n */\nList.prototype.add = function (data) {\n  const node = {data, next: null};\n\n  if (this.size === 0) {\n    this.tail = node;\n    this.head.next = node;\n    this.size++;\n    return node;\n  }\n\n  const oldTail = this.tail;\n  oldTail.next = node;\n  this.tail = node;\n  this.size++;\n\n  return node;\n};\n\n/**\n * Append any numbers of elements as new nodes at the end of the list.\n *\n * @param  {*} ...data  Any numbers of any type of data.\n * @return {Object} The last inserted node (tail).\n */\nList.prototype.addAll = function (...data) {\n  data.forEach(data => this.add(data));\n  return this.tail;\n};\n\n/**\n * Append data to a new node placed at the given index of the list.\n * Previous owner of this index becomes next in line after the new node.\n *\n * @param  {integer} index    The index at which the new node should be inserted.\n * @param  {*}       element  Any object to be used as data for the node.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object} The newly created node.\n */\nList.prototype.addAtIndex = function (index, data) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let prev = this.head;\n  let current = this.head.next;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    cursor++;\n  }\n\n  const node = {data, next: current};\n  prev.next = node;\n\n  this.size++;\n\n  return node;\n};\n\n/**\n * Append any number of data to new nodes placed at the given index.\n * Previous owner of the index becomes next in line after the latest\n * new node.\n *\n * @param  {integer} index    The index at which the new node should be inserted.\n * @param  {*}       ...data  Any number of any type of data.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object} The last of the newly created node.\n */\nList.prototype.addAllAtIndex = function (index, ...data) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let prev = this.head;\n  let current = this.head.next;\n  let cursor = 1;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    if (!current) {\n      this.tail = prev;\n    }\n    cursor++;\n  }\n\n  // Create array of newly created nodes from data.\n  // Process recursively and return reference to the latest\n  // node created when done.\n  const endNode = (function weave(i, nodes, data, prev, current) {\n    if (i === data.length) {\n      // Transplant both ends of array of new nodes to existing linked list.\n      prev.next = nodes[0];\n      const endNode = nodes[nodes.length - 1];\n      endNode.next = current;\n\n      // Kill references of nodes and return latest one.\n      nodes = null;\n      return endNode;\n    }\n\n    // Build node and link reference with previous one.\n    const node = {data: data[i], next: null};\n    if (i > 0) {\n      nodes[i - 1].next = node;\n    }\n\n    // Store node and repeat.\n    nodes.push(node);\n    return weave(++i, nodes, data, prev, current);\n  })(0, [], data, prev, current);\n\n  this.size += data.length;\n\n  return endNode;\n};\n\n/**\n * Return the node at the specified position.\n *\n * @param  {integer}    index   The index to look for.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object}  The node at the requested index.\n */\nList.prototype.get = function (index) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let current = this.head.next;\n\n  while (cursor < index) {\n    current = current.next;\n    cursor++;\n  }\n\n  return current;\n};\n\n/**\n * Remove the element at a given index.\n *\n * @param  {integer} index  The index of the node to remove.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object}  The deleted node.\n */\nList.prototype.remove = function (index) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let prev = this.head;\n  let current = this.head.next;\n  let next = current.next;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    next = current.next;\n    cursor++;\n  }\n\n  const deleted = current;\n  prev.next = next;\n  if (!next) {\n    this.tail = prev;\n  }\n  current = null;\n  this.size--;\n\n  return deleted;\n};\n\n/**\n * Return true if this list contains a node holding the specified data.\n *\n * @param  {*} data   The data to look for within nodes.\n * @return {boolean}  True if the data was found in a node.\n */\nList.prototype.contains = function (data) {\n  let current = this.head.next;\n\n  if (areEquals(current.data, data)) {\n    return true\n  }\n\n  let cursor = 1;\n  while (cursor < this.size) {\n    current = current.next;\n    if (areEquals(current.data, data)) {\n      return true;\n    }\n    cursor++;\n  }\n\n  return false;\n};\n\n/**\n * Remove and return the first node.\n *\n * @return {Object} The removed node.\n */\nList.prototype.shift = function () {\n  return this.remove(1);\n};\n\n\n/**\n * Remove and return the last node.\n *\n * @return {Object} The removed node.\n */\nList.prototype.pop = function () {\n  return this.remove(this.size);\n};\n\n/**\n * Replace data in the node at specified position.\n *\n * @param  {integer} index  The index of the node to edit.\n * @param  {*}       data   Any data to update the node's data field.\n * @return {void}\n */\nList.prototype.set = function (index, data) {\n  this.get(index).data = data;\n};\n\n/**\n * Return a shallow copy of the list.\n *\n * @return {Object} A singly linked list instance with copied nodes and data.\n */\nList.prototype.clone = function () {\n  return Object.assign(Object.create(this), this);\n};\n\n/**\n * Return an array compiling data from all nodes in the list.\n *\n * @return {Array}  An array of data based on the actual nodes' data.\n */\nList.prototype.toArray = function () {\n  let current = this.head.next;\n  let cursor = 1;\n  let a = [];\n\n  while (cursor <= this.size) {\n    a.push(current.data);\n    current = current.next;\n    cursor++;\n  }\n\n  return a;\n};\n\n/**\n * Remove all elements from the list and reseat its head.\n *\n * @return {void}\n */\nList.prototype.clear = function () {\n  this.head = {next: null};\n  this.tail = null;\n  this.size = 0;\n};\n\nmodule.exports = List;\n\n\n\n// WEBPACK FOOTER //\n// ./src/linkedlists/singly.js","module.exports = require(\"deep-equal\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"deep-equal\"\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}