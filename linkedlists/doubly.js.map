{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///doubly.js","webpack:///webpack/bootstrap 9d0bd94530f248305349","webpack:///./src/linkedlists/doubly.js","webpack:///external \"deep-equal\""],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","List","clear","areEquals","prototype","add","data","node","previous","next","size","head","tail","oldTail","addAll","_this","_len","arguments","length","Array","_key","forEach","addAtIndex","index","RangeError","cursor","prev","current","addAllAtIndex","_len2","_key2","endNode","weave","nodes","push","get","remove","deleted","contains","shift","pop","set","clone","Object","assign","create","toArray"],"mappings":"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","file":"doubly.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"deep-equal\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"deep-equal\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"deep-equal\")) : factory(root[\"deep-equal\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"deep-equal\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"deep-equal\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"deep-equal\")) : factory(root[\"deep-equal\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar areEquals = __webpack_require__(1);\n\t\n\tfunction List() {\n\t  this.clear();\n\t}\n\t\n\t/**\n\t * Append data to a new node at the end of the list.\n\t *\n\t * @param  {*}      data  Any type of data.\n\t * @return {Object} The new node.\n\t */\n\tList.prototype.add = function (data) {\n\t  var node = { data: data, previous: null, next: null };\n\t\n\t  if (this.size === 0) {\n\t    node.previous = this.head;\n\t    this.head.next = node;\n\t    this.tail = node;\n\t    this.size++;\n\t    return node;\n\t  }\n\t\n\t  var oldTail = this.tail;\n\t  oldTail.next = node;\n\t  node.previous = oldTail;\n\t  this.tail = node;\n\t  this.size++;\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Append any numbers of elements as new nodes at the end of the list.\n\t *\n\t * @param  {*} ...data  Any numbers of any type of data.\n\t * @return {Object} The last inserted node (tail).\n\t */\n\tList.prototype.addAll = function () {\n\t  var _this = this;\n\t\n\t  for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n\t    data[_key] = arguments[_key];\n\t  }\n\t\n\t  data.forEach(function (data) {\n\t    return _this.add(data);\n\t  });\n\t  return this.tail;\n\t};\n\t\n\t/**\n\t * Append data to a new node placed at the given index of the list.\n\t * Previous owner of this index becomes next in line after the new node.\n\t *\n\t * @param  {integer} index    The index at which the new node should be inserted.\n\t * @param  {*}       element  Any object to be used as data for the node.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object} The newly created node.\n\t */\n\tList.prototype.addAtIndex = function (index, data) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  var node = { data: data, previous: prev, next: current };\n\t  prev.next = node;\n\t\n\t  this.size++;\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Append any number of data to new nodes placed at the given index.\n\t * Previous owner of the index becomes next in line after the latest\n\t * new node.\n\t *\n\t * @param  {integer} index    The index at which the new node should be inserted.\n\t * @param  {*}       ...data  Any number of any type of data.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object} The last of the newly created node.\n\t */\n\tList.prototype.addAllAtIndex = function (index) {\n\t  for (var _len2 = arguments.length, data = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t    data[_key2 - 1] = arguments[_key2];\n\t  }\n\t\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t  var cursor = 1;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    if (!current) {\n\t      this.tail = prev;\n\t    }\n\t    cursor++;\n\t  }\n\t\n\t  // Create array of newly created nodes from data.\n\t  // Process recursively and return reference to the latest\n\t  // node created when done.\n\t  var endNode = function weave(i, nodes, data, prev, current) {\n\t    if (i === data.length) {\n\t      // Transplant both ends of array of new nodes to existing linked list.\n\t      prev.next = nodes[0];\n\t      nodes[0].previous = prev;\n\t      var _endNode = nodes[nodes.length - 1];\n\t      _endNode.next = current;\n\t      current.previous = _endNode;\n\t\n\t      // Kill references of nodes and return latest one.\n\t      nodes = null;\n\t      return _endNode;\n\t    }\n\t\n\t    // Build node and link reference with previous one.\n\t    var node = { data: data[i], next: null };\n\t    if (i > 0) {\n\t      nodes[i - 1].next = node;\n\t      node.previous = nodes[i - 1];\n\t    }\n\t\n\t    // Store node and repeat.\n\t    nodes.push(node);\n\t    return weave(++i, nodes, data, prev, current);\n\t  }(0, [], data, prev, current);\n\t\n\t  this.size += data.length;\n\t\n\t  return endNode;\n\t};\n\t\n\t/**\n\t * Return the node at the specified position.\n\t *\n\t * @param  {integer}    index   The index to look for.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object}  The node at the requested index.\n\t */\n\tList.prototype.get = function (index) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var current = this.head.next;\n\t\n\t  while (cursor < index) {\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  return current;\n\t};\n\t\n\t/**\n\t * Remove the element at a given index.\n\t *\n\t * @param  {integer} index  The index of the node to remove.\n\t * @throws {RangeError} If index is out of bounds.\n\t * @return {Object}  The deleted node.\n\t */\n\tList.prototype.remove = function (index) {\n\t  if (this.size === 0 || index < 1 || index > this.size) {\n\t    throw new RangeError('index is out of range');\n\t  }\n\t\n\t  var cursor = 1;\n\t  var prev = this.head;\n\t  var current = this.head.next;\n\t  var next = current.next;\n\t\n\t  while (cursor < index) {\n\t    prev = current;\n\t    current = current.next;\n\t    next = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  var deleted = current;\n\t  prev.next = next;\n\t  if (!next) {\n\t    this.tail = prev;\n\t  } else {\n\t    next.previous = prev;\n\t  }\n\t  current = null;\n\t  this.size--;\n\t\n\t  return deleted;\n\t};\n\t\n\t/**\n\t * Return true if this list contains a node holding the specified data.\n\t *\n\t * @param  {*} data   The data to look for within nodes.\n\t * @return {boolean}  True if the data was found in a node.\n\t */\n\tList.prototype.contains = function (data) {\n\t  var current = this.head.next;\n\t\n\t  if (areEquals(current.data, data)) {\n\t    return true;\n\t  }\n\t\n\t  var cursor = 1;\n\t  while (cursor < this.size) {\n\t    current = current.next;\n\t    if (areEquals(current.data, data)) {\n\t      return true;\n\t    }\n\t    cursor++;\n\t  }\n\t\n\t  return false;\n\t};\n\t\n\t/**\n\t * Remove and return the first node.\n\t *\n\t * @return {Object} The removed node.\n\t */\n\tList.prototype.shift = function () {\n\t  return this.remove(1);\n\t};\n\t\n\t/**\n\t * Remove and return the last node.\n\t *\n\t * @return {Object} The removed node.\n\t */\n\tList.prototype.pop = function () {\n\t  return this.remove(this.size);\n\t};\n\t\n\t/**\n\t * Replace data in the node at specified position.\n\t *\n\t * @param  {integer} index  The index of the node to edit.\n\t * @param  {*}       data   Any data to update the node's data field.\n\t * @return {void}\n\t */\n\tList.prototype.set = function (index, data) {\n\t  this.get(index).data = data;\n\t};\n\t\n\t/**\n\t * Return a shallow copy of the list.\n\t *\n\t * @return {Object} A singly linked list instance with copied nodes and data.\n\t */\n\tList.prototype.clone = function () {\n\t  return Object.assign(Object.create(this), this);\n\t};\n\t\n\t/**\n\t * Return an array compiling data from all nodes in the list.\n\t *\n\t * @return {Array}  An array of data based on the actual nodes' data.\n\t */\n\tList.prototype.toArray = function () {\n\t  var current = this.head.next;\n\t  var cursor = 1;\n\t  var a = [];\n\t\n\t  while (cursor <= this.size) {\n\t    a.push(current.data);\n\t    current = current.next;\n\t    cursor++;\n\t  }\n\t\n\t  return a;\n\t};\n\t\n\t/**\n\t * Remove all elements from the list and reseat its head.\n\t *\n\t * @return {void}\n\t */\n\tList.prototype.clear = function () {\n\t  this.head = { next: null };\n\t  this.tail = null;\n\t  this.size = 0;\n\t};\n\t\n\tmodule.exports = List;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"deep-equal\");\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// doubly.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9d0bd94530f248305349","const areEquals = require('deep-equal');\n\nfunction List() {\n  this.clear();\n}\n\n/**\n * Append data to a new node at the end of the list.\n *\n * @param  {*}      data  Any type of data.\n * @return {Object} The new node.\n */\nList.prototype.add = function (data) {\n  const node = {data, previous: null, next: null};\n\n  if (this.size === 0) {\n    node.previous = this.head;\n    this.head.next = node;\n    this.tail = node;\n    this.size++;\n    return node;\n  }\n\n  const oldTail = this.tail;\n  oldTail.next = node;\n  node.previous = oldTail;\n  this.tail = node;\n  this.size++;\n\n  return node;\n};\n\n/**\n * Append any numbers of elements as new nodes at the end of the list.\n *\n * @param  {*} ...data  Any numbers of any type of data.\n * @return {Object} The last inserted node (tail).\n */\nList.prototype.addAll = function (...data) {\n  data.forEach(data => this.add(data));\n  return this.tail;\n};\n\n/**\n * Append data to a new node placed at the given index of the list.\n * Previous owner of this index becomes next in line after the new node.\n *\n * @param  {integer} index    The index at which the new node should be inserted.\n * @param  {*}       element  Any object to be used as data for the node.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object} The newly created node.\n */\nList.prototype.addAtIndex = function (index, data) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let prev = this.head;\n  let current = this.head.next;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    cursor++;\n  }\n\n  const node = {data, previous: prev, next: current};\n  prev.next = node;\n\n  this.size++;\n\n  return node;\n};\n\n/**\n * Append any number of data to new nodes placed at the given index.\n * Previous owner of the index becomes next in line after the latest\n * new node.\n *\n * @param  {integer} index    The index at which the new node should be inserted.\n * @param  {*}       ...data  Any number of any type of data.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object} The last of the newly created node.\n */\nList.prototype.addAllAtIndex = function (index, ...data) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let prev = this.head;\n  let current = this.head.next;\n  let cursor = 1;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    if (!current) {\n      this.tail = prev;\n    }\n    cursor++;\n  }\n\n  // Create array of newly created nodes from data.\n  // Process recursively and return reference to the latest\n  // node created when done.\n  const endNode = (function weave(i, nodes, data, prev, current) {\n    if (i === data.length) {\n      // Transplant both ends of array of new nodes to existing linked list.\n      prev.next = nodes[0];\n      nodes[0].previous = prev;\n      const endNode = nodes[nodes.length - 1];\n      endNode.next = current;\n      current.previous = endNode;\n\n      // Kill references of nodes and return latest one.\n      nodes = null;\n      return endNode;\n    }\n\n    // Build node and link reference with previous one.\n    const node = {data: data[i], next: null};\n    if (i > 0) {\n      nodes[i - 1].next = node;\n      node.previous = nodes[i - 1];\n    }\n\n    // Store node and repeat.\n    nodes.push(node);\n    return weave(++i, nodes, data, prev, current);\n  })(0, [], data, prev, current);\n\n  this.size += data.length;\n\n  return endNode;\n};\n\n/**\n * Return the node at the specified position.\n *\n * @param  {integer}    index   The index to look for.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object}  The node at the requested index.\n */\nList.prototype.get = function (index) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let current = this.head.next;\n\n  while (cursor < index) {\n    current = current.next;\n    cursor++;\n  }\n\n  return current;\n};\n\n/**\n * Remove the element at a given index.\n *\n * @param  {integer} index  The index of the node to remove.\n * @throws {RangeError} If index is out of bounds.\n * @return {Object}  The deleted node.\n */\nList.prototype.remove = function (index) {\n  if (this.size === 0 || index < 1 || index > this.size) {\n    throw new RangeError('index is out of range');\n  }\n\n  let cursor = 1;\n  let prev = this.head;\n  let current = this.head.next;\n  let next = current.next;\n\n  while (cursor < index) {\n    prev = current;\n    current = current.next;\n    next = current.next;\n    cursor++;\n  }\n\n  const deleted = current;\n  prev.next = next;\n  if (!next) {\n    this.tail = prev;\n  } else {\n    next.previous = prev;\n  }\n  current = null;\n  this.size--;\n\n  return deleted;\n};\n\n/**\n * Return true if this list contains a node holding the specified data.\n *\n * @param  {*} data   The data to look for within nodes.\n * @return {boolean}  True if the data was found in a node.\n */\nList.prototype.contains = function (data) {\n  let current = this.head.next;\n\n  if (areEquals(current.data, data)) {\n    return true\n  }\n\n  let cursor = 1;\n  while (cursor < this.size) {\n    current = current.next;\n    if (areEquals(current.data, data)) {\n      return true;\n    }\n    cursor++;\n  }\n\n  return false;\n};\n\n/**\n * Remove and return the first node.\n *\n * @return {Object} The removed node.\n */\nList.prototype.shift = function () {\n  return this.remove(1);\n};\n\n\n/**\n * Remove and return the last node.\n *\n * @return {Object} The removed node.\n */\nList.prototype.pop = function () {\n  return this.remove(this.size);\n};\n\n/**\n * Replace data in the node at specified position.\n *\n * @param  {integer} index  The index of the node to edit.\n * @param  {*}       data   Any data to update the node's data field.\n * @return {void}\n */\nList.prototype.set = function (index, data) {\n  this.get(index).data = data;\n};\n\n/**\n * Return a shallow copy of the list.\n *\n * @return {Object} A singly linked list instance with copied nodes and data.\n */\nList.prototype.clone = function () {\n  return Object.assign(Object.create(this), this);\n};\n\n/**\n * Return an array compiling data from all nodes in the list.\n *\n * @return {Array}  An array of data based on the actual nodes' data.\n */\nList.prototype.toArray = function () {\n  let current = this.head.next;\n  let cursor = 1;\n  let a = [];\n\n  while (cursor <= this.size) {\n    a.push(current.data);\n    current = current.next;\n    cursor++;\n  }\n\n  return a;\n};\n\n/**\n * Remove all elements from the list and reseat its head.\n *\n * @return {void}\n */\nList.prototype.clear = function () {\n  this.head = {next: null};\n  this.tail = null;\n  this.size = 0;\n};\n\nmodule.exports = List;\n\n\n\n// WEBPACK FOOTER //\n// ./src/linkedlists/doubly.js","module.exports = require(\"deep-equal\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"deep-equal\"\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}